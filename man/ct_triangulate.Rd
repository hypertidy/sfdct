% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sfct.R
\name{ct_triangulate}
\alias{ct_triangulate}
\alias{ct_triangulate.sf}
\alias{ct_triangulate.sfg}
\title{Constrained Delaunay Triangulation}
\usage{
ct_triangulate(x, ...)

\method{ct_triangulate}{sfg}(x, trim = TRUE, ...)

\method{ct_triangulate}{sf}(x, trim = TRUE, ...)
}
\arguments{
\item{x}{simple feature geometry or data frame}

\item{...}{arguments for \code{\link[RTriangle]{triangulate}}, see details}

\item{trim}{drop triangles that fall "outside" i.e. "holes" and non-convex regions, \code{TRUE} by default}
}
\value{
simple feature column \code{\link[sf]{st_sfc}} or data frame \code{\link[sf]{st_sfc}}
}
\description{
Triangulate simple features including the input edges as constraints, rather than
being bounded to the convex hull.
}
\details{
This is not a Delaunay Triangulation, but is "mostly-Delaunay". All POLYGON, LINESTRING, MULTIPOLYGON and MULTILINESTRING inputs
are broken down into line segments that are included in the mesh. Holes are removed
by default, but can be retained with the \code{trim} argument.

The triangles are collected as POLYGONs within a GEOMETRYCOLLECTION, and in the case of an `sf` object
it's returned within the original input data frame.

There's no way currently to retain the set of shared vertices, or the segment or
the triangle indices.

Further arguments may be passed down to the underlying triangulation function \code{\link[RTriangle]{triangulate}}.
Note that planar coordinates are assumed, no matter what projection the input is in. There's no
sensible meaning to a value for \code{a} in units m^2 for a layer that is in longitude/latitude, for those
use "area in square degrees", the straightforward meaning in planar coordinates.
These arguments are, from the documention of that function:
\itemize{
\item{a}{ a Maximum triangle area. If specified, triangles cannot be
larger than this area.}
\item{q}{ Minimum triangle angle in degrees.}
\item{Y}{ If \code{TRUE} prohibits the insertion of Steiner points
on the mesh boundary.}
\item{j}{ If \code{TRUE} jettisons vertices that are not part of
the final triangulation from the output.}
\item{D}{ If \code{TRUE} produce a conforming Delaunay
triangulation. This ensures that all the triangles in the mesh are
truly Delaunay, and not merely constrained Delaunay.  This option
invokes Ruppert's original algorithm, which splits every
subsegment whose diametral circle is encroached.  It usually
increases the number of vertices and triangles.}
\item{S}{ Specifies the maximum number of added Steiner points.}
\item{V}{ Verbosity level. Specify higher values  for more detailed
information about what the Triangle library is doing.}
\item{Q}{ If \code{TRUE} suppresses all explanation of what the
Triangle library is doing, unless an error occurs. }
}
}
\note{
GEOMETRYCOLLECTION as input is not yet supported.
}
\examples{
library(sf)
nc <- st_read(system.file("shape/nc.shp", package="sf"))
nc_triangles <- ct_triangulate(nc[, "NAME"])
plot(nc[, "NAME"])
plot(nc_triangles, add = TRUE, col = NA, lty = "dotted")
idx <- c(4, 5, 6, 7, 8, 20, 21)
op <- par(mfrow = c(2, 1))
if (packageVersion("sf") <= '0.2.8'){
nc <- st_transform(nc, "+proj=eqc +ellps=WGS84")
}
plot(st_triangulate(nc[idx, "NAME"]), col = "grey")
plot(ct_triangulate(nc[idx, "NAME"]))

par(op)
\dontrun{
  library(rworldmap)
  data(countriesLow)
  sworld <- st_as_sf(countriesLow)
  local_places <- c("Indonesia", "Papua New Guinea", "New Zealand", "Australia")
  sworld <- sworld[sworld$SOVEREIGNT \%in\%  local_places, ]
  ## the centre of the universe
  llprj <- "+proj=laea +ellps=WGS84 +lat_0=-42 +lon_0=147 +no_defs"
  sworld <- st_transform(sworld, crs = llprj)

  x <- ct_triangulate(sworld)
  plot(x[, "SOVEREIGNT"], main = "constrained vs convex\\n Delaunay triangulation")
  acols <- sf::sf.colors(nrow(sworld)
  plot(st_triangulate(sworld), col = acols, alpha = 0.3), border = NA, add = TRUE)
}
}

